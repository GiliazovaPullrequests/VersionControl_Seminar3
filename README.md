# __Инструкция для работы с Git.__

## __Что такое Git?__

__*Git*__ - это одна из реализаций распределённых систем контроля версий, и имеющая как и локальные, так и удалённые репозитории. Является самой популярной реализацией систем контроля версий в мире.

* ### __Три состояния *Git*.__

Основное, что требуется запомнить, чтобы дальнейшее
освоение Git прошло без проблем. Файлы в Git могут находиться в трех основных состояниях: зафиксированном, модифицированном и индексированном. 

__*Зафиксированное*__ (committed) состояние означает, что данные надежно сохранены
в локальной базе.

__*Модифицированное*__ (modified) состояние означает, что изменения
уже внесены в файл, но пока не зафиксированы в базе данных.

__*Индексированное*__ (staged) состояние означает, что вы пометили текущую версию модифицированного
файла как предназначенную для следующей фиксации.

В результате Git-проект разбивается на три основные области: папка Git, рабочая
папка и область индексирования.

* ### __Создание репозитория в Git.__

Есть два подхода к созданию Git-проекта. Можно взять существующий проект или
папку и импортировать в Git. А можно клонировать уже существующий репозиторий с другого сервера.

* ### __Инициализация репозитория в существующей папке.__

Чтобы начать слежение за существующим проектом, то есть создать репозиторий, перейдите в папку этого проекта и введите команду "__*git init*__"

* ### __Клонирование существующего репозитория.__

Получение копии существующего репозитория, например проекта, в котором вы
хотите принять участие, выполняется командой "__*git clone*__". Те, кто знаком с другими VCS, например с Subversion, могли заметить, что в данном случае используется команда клонирования (__*clone*__), а не выгрузки (__*checkout*__). Это крайне важное отличие. Вы получаете не просто рабочую копию, а полную копию практически всех данных с сервера. Команда "__*git clone*__" по умолчанию забирает все версии всех файлов за всю историю проекта. Это означает, что при повреждении серверного диска практически любой клон на любом из клиентов может использоваться для возвращения сервера в состояние, в котором он пребывал до момента клонирования (при этом может быть утрачена часть хуков со стороны сервера, но все данные, относящиеся к версиям, будут на месте).

* ### __Запись изменений в репозиторий.__

Итак, у вас есть настоящий *Git*-репозиторий и некая выгрузка, то есть рабочие копии
файлов нашего проекта. Теперь в файлы можно вносить изменения и фиксировать их, как только проект достигнет состояния, которое вы хотели бы сохранить. Помните, что каждый файл в рабочей папке может пребывать в одном из двух состояний: отслеживаемом и неотслеживаемом. Первый случай — это файлы, входящие в последний снимок системы; они могут быть неизмененными, измененными и подготовленными к фиксации. Второй случай — это все остальные файлы рабочей папки, не вошедшие в последний снимок системы и не проиндексированные для последующей фиксации. После первого клонирования репозитория все файлы оказываются отслеживаемыми и неизмененными, потому что вы просто выгрузили их и пока не отредактировали.
Отредактированный файл *Git* рассматривает как измененный, ведь его состояние
отличается от последнего зафиксированного. Вы индексируете эти измененные
файлы, фиксируете все проиндексированные изменения, после чего цикл повторяется.

* ### __Проверка состояния файлов.__

Основным инструментом определения состояния файлов является команда
"__*git status*__".

* ### __Слежение за новыми файлами.__

Чтобы начать слежение за новым файлом, воспользуйтесь командой "__*git add*__".

Все проиндексированные файлы перечисляются под заголовком *Changes to be committed*. Если в этот момент произвести фиксацию, версия файла, существовавшая на момент выполнения команды "__*git add*__", попадет в историю снимков состояния. Надеюсь, вы помните, что за командой "__*git init*__" следовала команда "__*git add*__" (имена файлов), что заставило систему начать слежение за файлами в папке. Команда "__*git add*__" работает с маршрутом доступа к файлу или к папке; если указан путь к папке, команда рекурсивно добавляет все находящиеся в ней файлы.

* ### __Краткий отчет о состоянии.__

Команда "__*git status*__" дает исчерпывающий, хотя и многословный результат. Но в *Git* существует флаг, позволяющий получить сведения в более компактной форме. Запустив команду "__*git status -s*__" или "__*git status --short*__", вы получите упрощенный вариант вывода.

* ### __Игнорирование файлов.__

Бывает так, что некоторый класс файлов вы не хотите ни автоматически добавлять в репозиторий, ни видеть в списке неотслеживаемых. В эту категорию, как правило, попадают автоматически генерируемые файлы, например журналы регистрации или файлы, генерируемые системой сборки. В подобных случаях создается файл "__*.gitignore*__" со списком соответствующих паттернов.

* ### __Отмена изменений.__

Необходимость отмены внесенных изменений может возникнуть на любой стадии проекта. В этом разделе мы рассмотрим несколько базовых инструментов, позволяющих это сделать. Однако здесь следует быть крайне осторожным, ведь после отмены далеко не всегда существует возможность вернуться в предшествующее состояние. Это одна из немногих ситуаций при работе с Git, когда неверные действия могут привести к потере результатов вашего труда.

Необходимость отмены чаще всего возникает при слишком ранней фиксации изменений, когда вы забыли добавить в коммит какие-то файлы или ошиблись с сообщением фиксации. Для повторного сохранения версии в такой ситуации можно воспользоваться командой "__*git commit –amend*__".

Эта команда берет область индексирования и включает в коммит всю обнаруженную там информацию. Если после последней фиксации версии вы не внесли никаких изменений (к примеру, эта команда была запущена непосредственно после предыдущего коммита), снимок состояния останется таким же, как и был, изменится только сообщение фиксации.
Откроется тот же самый редактор сообщения фиксации, но с уже введенной туда версией сообщения к предыдущему коммиту. Вы можете обычным образом отредактировать это сообщение, но предшествующий коммит в результате будет переписан.

* ### __Удаленные репозитории.__

Для совместной работы над проектами *Git* требуются навыки управления удаленными репозиториями. Удаленные репозитории представляют собой версии проекта, хранимые в Интернете или где-то в сети. Их может быть несколько, и каждый в общем случае доступен вам только для чтения или же для чтения и записи. Вы должны уметь отправлять данные в удаленный репозиторий и извлекать их оттуда каждый раз, когда требуется обменяться результатами работы. Кроме того, вы должны знать, как добавить удаленный репозиторий, как удалить репозиторий, который больше не используется, как управлять различными удаленными ветками и делать их отслеживаемыми и неотслеживаемыми, и многое другое. В данном разделе мы рассмотрим некоторые из этих приемов.

* ### __Добавление удаленных репозиториев.__

Ранее уже не раз упоминался и демонстрировался процесс добавления удаленных репозиториев, но теперь мы рассмотрим его в явном виде. Чтобы добавить такой репозиторий под коротким именем, которое упростит дальнейшие обращения к нему, используйте команду "__*git remote add [сокращенное имя] [url]*__". Например, "__*git remote add pb https://github.com/paulboone/ticgit*__".

Теперь вместо полного URL-адреса в командную строку можно вводить имя pb. К примеру, для скачивания всей информации, которая есть у коллеги, но отсутствует у вас, используйте команду "__*git fetch pb*__".

Ветка __*master*__ этого коллеги теперь доступна вам локально как __*pb/master*__. Вы можете выполнить ее слияние с одной из ваших веток или перейти в нее, если требуется просто проверить ее содержимое.

* ### __Извлечение данных из удаленных репозиториев.__

Как вы уже видели, извлечение данных из удаленных проектов выполняется такой
командой: "__*git fetch [имя удаленного репозитория]*__".

Эта команда связывается с удаленным проектом и извлекает оттуда все пока отсутствующие у вас данные. После этого у вас должны появиться ссылки на все ветки удаленного проекта, которые можно подвергнуть слиянию или просмотреть.

При клонировании данная команда автоматически добавляет удаленный репозиторий под именем __*«origin»*__. Соответственно команда "__*git fetch origin*__" извлекает все, что появилось на этом сервере после его клонирования (или после момента последнего извлечения информации). Важно понимать, что команда "__*git fetch*__" помещает все данные в ваш локальный репозиторий, — она не выполняет автоматическое слияние с ветками, с которыми вы работаете в данный момент, и вообще никак не затрагивает эти ветки. Слияние вы выполните вручную, как только в этом возникнет необходимость.

Если же у вас есть ветка, настроенная на слежение за какой-то удаленной веткой, команда "__*git pull*__" будет автоматически извлекать информацию из удаленной ветки и выполнять слияние с текущей веткой. В некоторых случаях такой порядок вещей оказывается проще и удобнее; кроме того, по умолчанию команда "__*git clone*__" автоматически
настраивает вашу локальную ветку master на слежение за удаленной веткой __*master*__ (она может иметь и другое имя) на сервере, с которого вы выполняли клонирование. В общем случае команда "__*git pull*__" извлекает данные с сервера, который вы клонировали, и автоматически пытается слить их с вашим текущим рабочим кодом.

* ### __Отправка данных в удаленный репозиторий.__

Чтобы поделиться результатами своего труда, их нужно отправить в репозиторий. Это делается простой командой "__*git push [имя удаленного сервера] [ветка]*__". Для отправки ветки __*master*__ на сервер __*origin*__ (еще раз напоминаем, что в процессе клонирования эти имена присваиваются автоматически) следует написать: "__*git push origin master*__".

Команда сработает только при условии, что клонирование осуществлялось с сервера, где у вас есть доступ на запись, и за это время никто не отправлял туда свои данные. Если вы выполнили клонирование одновременно с другим пользователем и он уже отправил результаты своей работы на сервер, ваша попытка отправки данных окончится неудачей. Вам сначала нужно скачать все добавленное этим пользователем и встроить это в свои данные, и только после этого появится возможность воспользоваться командой "__*push*__".

* ### __Просмотр удаленных репозиториев.__

Для получения дополнительной информации о конкретном удаленном репозитории применяется команда "__*git remote show [имя удаленного сервера]*__". Например,"__*git remote show origin*__".

Выводятся URL-адрес удаленного репозитория и информация об отслеживаемых ветках. Команда услужливо сообщает, что если, находясь в ветке __*master*__, вы запускаете команду "__*git pull*__", ветка __*master*__ с удаленного сервера будет автоматически слита с вашей сразу же после скачивания всех необходимых данных. Кроме того, она выводит на экран список всех скачанных ею ссылок.

* ### __Удаление и переименование удаленных репозиториев.__

Переименование ссылок осуществляется командой "__*git remote rename*__", меняющей сокращенные имена удаленных репозиториев.

Имеет смысл упомянуть, что эта команда умеет менять и имена удаленных веток. Теперь к ветке __*pb/master*__ нужно обращаться по имени __*paul/master*__.

Если по какой-то причине вы хотите удалить ссылку на удаленный репозиторий (например, вы поменяли сервер, больше не используете конкретное зеркало или участник проекта перестал вносить в него вклад), используйте команду "__*git remote rm*__".

* ### __Создание ветки.__

Для того, чтобы создать ветку, нужно использовать "__*git branch имя_ветки*__" или "__*git checkout -b имя_ветки*__"

* ### __Заключение.__

Итак, вы научились выполнять все базовые локальные операции в Git: создавать
или клонировать репозитории, вносить изменения, индексировать и фиксировать
их, а также просматривать историю всех сделанных в репозитории изменений.
Пришла пора познакомиться с самым важным преимуществом Git — моделью
ветвления.

---

## __Основные команды Git.__

* __*echo "## Заголовок"" >> FileName.md*__ - создание файла с расширением *"md"* с заголовком в файле.

* __*git --version*__ - проверки текущей версии *Git*.

* __*git init*__ - инициализация локального/пустого репозитория.

* __*git status* - получить информацию от *Git*__ о текущем состоянии файлов, есть ли изменения, которые нужно закоммитить.

* __*git add* <*имя файла*> + *Tab*__ - добавляем версионность файлу (добавляем содержимое рабочего каталога в индекс (staging area) для последующего коммита).

Для добавления изменений в коммит (сохранение) используется команда *git add*. Чтобы использовать команду *git add*, напишите *git add имя_файла*.

* __*git add .*__ - добавить версионность всем файлам.

* __*git commit -m "Message"*__ - фиксация изменений файлов с сообщением *"Message"*.

* __*git commit -am "Message"*__ - команда для фиксации изменений всех файлов с сообщением *"Message"* (не требуется команда *git add*).

* __*git log*__ - вывод истории коммитов в хронологическом порядке (журнал изменений) с их хэш-кодами.

* __*git log --oneline*__ - вывод __краткой__ истории коммитов в хронологическом порядке с их хэш-кодами.

* __*git log --graph*__ - визуализация всех веток.

* __*git checkout* <*+ 4 и более первых символов коммита (хэша_коммита)*>__ -  перемещение между версиями.

* __*git checout master*__ -  переход на самое актуальное текущее состояние.

* __*git checkout* <*Name*>__ - переход на ветку наименованием *"Name"*.

* __*git checkout -b* <*Name*>__ - создание ветки и переход в неё (в ветку *"Name"*) без дополнительных команд.

* __*git diffrend*__ - вывод изменений на текущий момент по отношению к последнему коммиту (показывает разницу между текущим файлом и сохранённым).

* __*git branch* <*Name*>__ - создать ветку наименованием *"Name"*.

* __*git -d branch* <*Name*>__ - удалить ветку наименованием *"Name"*.

* __*git merge* <*Name*>__ - слить ветку наименованием *"Name"* с текущей.

* __*clear*__ - очистить записи в терминале.

* __*.gitignore*__ - создание файла с наименованием __*.gitignore*__ и перечислением в нём наименований файлов и/или папок (к наименованию папки добавить в конец "/"), приведёт к их игнормрованию *Git*'ом.

* __*mkdir* <*Name*>__ - создание папки наименованием *"Name"* с текущей.

* __*cd* <*Name*>__ - переход в папку наименованием *"Name"* с текущей.

* __*ls -a*__ - показывает содерживое папки (не работает в *powershell*).

* __*git checkout -b* <*Name*>__ - создаёт ветку и переходит в неё без дополнительных команд.

* __*git log --oneline*__ - краткий журнал изменений.

* __*git reflog*__ - журнал ссылок для указателя *HEAD*.

* __*git clone <*url*>*__ - копировать внешний репозиторий на свой компьютер. Команда составная: загружает все изменения и пытается слить все ветки на локальном компьютере ив удалённом репозитории

* __*git pull*__ - скачать всё из текщего репозитория и автоматически делает *merge* с вашей версией.

* __*git push*__ - отправить свою версию репозитория.

* __*git request*__ - предложить изменения, то есть запрос на вливание изменений в репозиторий.

---
---

# Инструкция для работы с языком разметки Markdown.

## __Выделение текста.__

* ### __Заголовки.__

Для выделения текста заголовка, обрамите его решеткой (#). Количество символов "#" задаёт уровень заголовка (поддерживается 6 уровней).

* ### __Курсивный текст.__

Для выделения текста курсивом, обрамите его звёздочками (*) или  нижним подёркиванием ( _ ), например, вот так: 
*Курсивное начертание* или _Курсивное начертание_.

* ### __Полужирный текст.__

Для выделения текста полужирным, обрамите его двумя звёздочками (**) или двумя нижними подёркивания ( __ ), например, вот так: **Полужирный** или __Полужирное начертание__ 

* ### __Полужирный курсивный текст.__

Для выделения текста полужирным курсивом, обрамите его тремя звёздочками (***) или двумя звёздочками и одним нижним подчёркиванием ( **_ ) , например, вот так: ***Полужирное курсивное начертание*** или **_Полужирный курсивный текст._**

* ### __Зачёркнутый текст.__

Для того, чтобы зачеркнуть текст, обрамите его двумя "тильдами" (~~), например, вот так:
~~Зачёркнутый текст~~.

* ### __Подчёркнутый текст.__

Для подчёркивания текста сделай вот так:    
<u>underlined text</u>

## __Блок кода.__

Для выделения блока кода сделай вот так:

```
sudo npm install vsoagent-installer -g
```

или вот так

```html
<nav class="nav nav-primary">
  <ul>
    <li class="tab-conversation active">
      <a href="#" data-role="post-count" class="publisher-nav-color" data-nav="conversation">
        <span class="comment-count">0 комментариев</span>
        <span class="comment-count-placeholder">Комментарии</span>
      </a>
    </li>
    <li class="dropdown user-menu" data-role="logout">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown">
        <span class="dropdown-toggle-wrapper">
          <span>
            Войти
          </span>
        </span>
        <span class="caret"></span>
      </a>
    </li>
  </ul>
</nav>
```

или вот так

```js
const count = records.length;
```

или вот так

 ```csharp
Console.WriteLine("Hello, World!");
```

## __Списки.__

* ### __Ненумерованные списки.__

Для выделения ненумерованных списков, укажите звёздочку (*) или дефис (-) вначале текста, например, вот так:

* Элемент 1.
- Элемент 2.

* ### __Нумерованные списки.__

Для выделения нумерованных списков, укажите цифру вначале текста, например, вот так:

1. Элемент 1.

* ### __Вложенные списки.__

Для выделения вложенных списков делай так:

1. Первый пункт.
   - Элемент  1
   - Элемент  2
   - Элемент  3
1. Второй пункт.
   - Вложенный пункт 1
      - Дополнительный вложенный элемент 1
      - Дополнительный вложенный элемент 2
      - Дополнительный вложенный элемент 3
   - Вложенный пункт 2
   - Вложенный пункт 3

## __Цитаты.__

Процитирование отдельных строк текста возможно указанием перед текстом специального знака (>), например, вот так: 

> Отпишись от моей страницы.  
И забудь мой ебрежный стиль -  
Нам с тобою не пожениться  
И наследников не крестить.
С телефона уже в постели,  
Не терзать непокорный "Скайп".  
Отпишись уже, в самом деле,  
И ступай.  
                *(2013)*

Используем много > символов для вложения в кавычки текста. Блоки кавычек текста используют одинаковый > уровень между несколькими строками.
>> Вот так.

## __Ссылки.__

 В файлах и мини-приложениях Markdown можно задать текстовые гиперссылки для URL-адреса с помощью стандартного синтаксиса ссылки Markdown, например, вот так:

[Что-то красивое](https://i.ytimg.com/vi/9kKXTr17jjk/maxresdefault.jpg "Взгляни это")

## __Изображения.__

Для отображения картинки напиши вот так: ![Описание изображения](Путь к изображению)

![Хорошая история](/images/Дороро.jpg)

![Красота^_^](/images/DarlingInTheFranxx.jpg)

## __Таблицы.__

Для постороения таблицы сделай вот так:

| Заголовок 1 | Заголовок 2 | Заголовок 3 |  
|-----------|:-----------:|-----------:|  
| Ячейка  A1 | Ячейка  A2 | Ячейка  A3 |  
| Ячейка  B1 | Ячейка  B2 | Ячейка  B3<br/>Вторая строка текста |

## __Формулы.__

-

$$
A_{triangle}=\frac{1}{2}({b}\cdot{h})
$$

-  

$$
\sum_{i=1}^{10} t_i
$$

-

$$
\int_0^\infty \mathrm{e}^{-x}\,\mathrm{d}x
$$

## __Символы.__

$
\alpha, \beta, \gamma, \delta, \epsilon, \zeta, \eta, \theta, \kappa, \lambda, \mu, \nu, \omicron, \pi, \rho, \sigma, \tau, \upsilon, \phi, ...
$  

$\Gamma,  \Delta,  \Theta, \Lambda, \Xi, \Pi, \Sigma, \Upsilon, \Phi, \Psi, \Omega$

---

# __Заключение.__

Я старался :)  
Спасибо! 